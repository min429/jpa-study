※ 배치사이즈는 지연로딩에 대해 적용됨

# 다대일 단방향

- 역방향 참조가 많은 경우, 예를들어 team들을 조회하고 항상 그 team들에 대한 member list가 필요한 경우, 쿼리가 한줄 더 필요하지만 별로 문제 없는듯
  -> 쿼리 총 두번 날라감(team 리스트 조회 1번, team_id 리스트를 통해 member 리스트 조회 1번)
- member list는 보통 해당 team에 대한 member list는 모두 가져오는 경우가 대부분이라 별로 문제되지 않을 것 같음.
- 만약 member list가 너무 많아서 이마저도 문제가 된다 -> member에 대해서 가져올 때 페이징처리를 하던지 해야할듯

# 다대일 양방향

- 지연로딩으로 인해 일단 team을 가져오고 member 리스트는 가져오지 않음
- 개별 member의 필드 값에 접근하면 member 리스트를 가져옴(list.getMembers().size()도 마찬가지)
- 이때 한번에 데이터를 다 가져와버리면 메모리낭비이므로 필요한 만큼만 가져오도록 배치사이즈를 지정해줌
- 이렇게 되면 특정 team의 member 리스트를 조회할 때 member 리스트를 한번에 가져오지 않고 배치사이즈 크기의 team id 리스트 만큼만 가져옴.
- 예를들어, team id가 1~200까지 있고, 배치사이즈가 100일 때, team id가 150인 member list를 가져오게 되면 조회쿼리에 team_id in (101, 102, …, 200) 쿼리가
  붙어서 일부만 가져오게 됨
- 이 때문에 다대일 단방향에 비해 쿼리 자체는 더 많이 나가지만, 그렇게 크게 부담되진 않는 수준인 것 같고, 대신 객체지향적 프로그래밍이 가능한 게 장점인듯

# N+1 문제 발생하는 상황

> 기본적으로 지연로딩/즉시로딩 상관없이 N+1 문제는 발생할 수 있음. 하지만 배치사이즈만 걸어주면 쿼리 양을 N -> (N / 배치사이즈)로 줄일 수 있음

## 즉시로딩의 경우에 N+1 문제가 발생할 수 있다.

- 즉시로딩의 경우, Spring Data Jpa의 쿼리 메서드(ex. findBy~)에서 JPQL을 사용하고, 이 JPQL은 SQL로 그대로 번역되기 때문에 문제가 발생한다.
- 예를들어, findByAll 같은 경우, (SELECT u FROM User u)이 되는데, 이게 그대로 (SELECT * FROM user)가 되어서 쿼리를 보내게 된다.
- 이때, 일단 findByAll로 모든 User 데이터를 가져왔지만 가져오고 보니 즉시로딩으로 세팅되어있음을 확인하고, 그제서야 User와 연관된 엔티티를 조회하게 된다.
- 문제는, 이렇게 연관 엔티티들을 조회할 때, user_id 리스트 기반으로 한번에 가져오면 좋겠지만 user_id별로 각각 쿼리를 보내게 되고 결국 N+1 문제가 발생한다.
- 따라서 잠재적인 N+1 문제를 방지하기 위해서는 즉시로딩을 사용하지 말아야 한다. 대안으로 즉시로딩 대신 각 쿼리별로 fetch join을 사용하면 대부분의 경우 해결된다.
- fetch join은 엔티티간 join을 JPQL로 직접 작성한다.

[JPA 모든 N+1 발생 케이스와 해결책](https://velog.io/@jinyoungchoi95/JPA-%EB%AA%A8%EB%93%A0-N1-%EB%B0%9C%EC%83%9D-%EC%BC%80%EC%9D%B4%EC%8A%A4%EA%B3%BC-%ED%95%B4%EA%B2%B0%EC%B1%85)

## 지연로딩의 경우에도 N+1 문제가 발생할 수 있다.

> Post(1) : Comment(N) 구조 가정

### 단방향의 경우

Comment -> Post 순으로 조회

- Comment 모두 조회, Post 모두 조회 하는게 아닌 이상 무조건 N+1 문제가 발생함

### 양방향의 경우

Post -> Comment 순으로 조회

- Post 각각에 대해 반복을 통해 comments를 가져오는 방식은 N+1 문제가 발생
- Post를 한번에 가져온 다음 post_id를 가진 comments를 한번에 조회하면 N+1 문제 발생x (총 쿼리 2회)

Comment -> Post 순으로 조회

- Comment 모두 조회, Post 모두 조회 하는게 아닌 이상 무조건 N+1 문제가 발생함

# 페치 조인

> 페치 조인은 JPQL을 직접 사용하여 즉시로딩 대신 연관 엔티티를 한번에 가져올 수 있는 방법이다.

## 한계

- 다대일 연관관계에서, '다' 쪽에 해당하는 엔티티를 조회할 때는 fetch join을 사용한 페이징이 가능하다.
- 하지만, '일' 쪽에 해당하는 엔티티를 조회할 때는 fetch join을 사용한 페이징이 불가능하다.

예를 들어보자. 만약 Member(N) : Team(1)의 관계인 경우, Member와 Team을 조인하게 되면 다음 현상이 발생한다.

| member_id | member_name | team_id | team_name |
|-----------|-------------|---------|-----------|
| 1         | 페이커         | 1       | t1        |
| 2         | 케리아         | 1       | t1        |
| 3         | 데프트         | 2       | drx       |
| 4         | 제카          | 2       | drx       |

주목할 점은, row 자체는 중복이 없다. 즉, member에 대해서만 보면 중복된 row가 없다.
하지만, team에 대해서만 보면, 중복된 row가 있다. (1, t1), (2, drx)

만약 member에 대해 fetch join을 통해 페이징을 하게 된다면, 이 조회 결과에 직접 offset과 limit을 설정해서 DB에서 페이징 처리를 할 수 있다.
이렇게 페이징 처리된 결과를 그대로 엔티티 리스트에 담아버리면 된다.

하지만, team에 대해 fetch join을 통해 페이징을 하게 된다면, 이 조회 결과에 직접 offset과 limit을 설정해서 DB에서 페이징 처리를 하면 안된다.
왜냐하면, team 데이터를 우리가 원했던 만큼 정확히 가져올 수 없기 때문이다.
예를들어, 우리는 페이징 처리를 해서 page가 0이고, size가 2만큼만 team 엔티티를 조회하고 싶다고 하자.
이때 우리가 기대하는 결과는 team_id 1, 2인 엔티티를 가져오는 것이다.
page가 0이고 size가 2인 경우, offset은 0, limit은 2이 된다.
이때 DB 조회결과에 offset: 0, limit: 2을 적용하게 되면 우리는 다음과 같은 결과를 얻게 될 것이다.

| member_id | member_name | team_id | team_name |
|-----------|-------------|---------|-----------|
| 1         | 페이커         | 1       | t1        |
| 2         | 케리아         | 1       | t1        |

team_id가 1인 데이터만 가져와버린 것이다.
이 때문에 hibernate는 DB 수준에서 페이징 처리를 하지 않고, 일단 모든 데이터를 전부 가져온다음, 메모리에서 페이징 처리를 하게 된다.
(이때 메모리에서 페이징 처리를 한다는 경고 로그도 뜬다.)

이렇게 되면, 페이징 처리를 하는 의미가 사실상 없다.
페이징은 DB에서 일부 데이터만 조회하여 메모리 부담을 줄이고, 성능을 향상시키려는 의도인데,
DB에서 모든 데이터를 조회해버리면 무슨 소용인가. 이런 이유로 '일' 쪽에 해당하는 엔티티를 조회할 때는 fetch join을 사용하면 안된다.

그 대안으로, 배치사이즈를 적용하면 된다. 일단 team 엔티티에 대해서만 먼저 조회하고, member 엔티티가 필요할 때 배치사이즈만큼 한번에 가져오게 된다.
이때 배치사이즈 만큼의 team_id에 해당하는 member 엔티티 리스트를 in 연산자를 통해 한번에 조회한다.
만약 배치사이즈가 2라면, 일단 먼저 team 엔티티를 두개 조회한 뒤, member 엔티티에 접근할 때 team_id 1, 2에 해당하는 member 엔티티들을 한번에 가져오게 된다.